# cadr - AOT Compiler

`cadr` (pronounced "cad-er", from the Lisp function) compiles Consair Lisp source files to LLVM IR, which can then be compiled to native executables.

## Usage

```bash
cadr <input.lisp>              # Output LLVM IR to stdout
cadr <input.lisp> -o <out.ll>  # Output LLVM IR to file
cadr --help                    # Show help
cadr --version                 # Show version
```

## Basic Workflow

1. Write your Consair program
2. Compile to LLVM IR with `cadr`
3. Compile to native with `clang`
4. Run the executable

```bash
# Write program
cat > factorial.lisp << 'EOF'
(label factorial (lambda (n)
  (cond ((= n 0) 1)
        (t (* n (factorial (- n 1)))))))
(println "10! =" (factorial 10))
EOF

# Compile to LLVM IR
cadr factorial.lisp -o factorial.ll

# Compile to native
clang -O3 factorial.ll -o factorial

# Run
./factorial
# Output: 10! = 3628800
```

## Using lli (LLVM Interpreter)

For quick testing, use `lli` to interpret the LLVM IR directly:

```bash
cadr program.lisp | lli
# or
cadr program.lisp -o program.ll && lli program.ll
```

## Compilation Output

The generated LLVM IR includes:
- Runtime functions (memory management, printing, arithmetic)
- Compiled user code
- A `main` function that executes all top-level expressions

Example output structure:
```llvm
; Consair AOT Compiled Output
; Generated by cadr

; Runtime type definitions
%RuntimeValue = type { i8, i64 }

; Runtime functions
define %RuntimeValue @rt_cons(...) { ... }
define %RuntimeValue @rt_car(...) { ... }
; ... more runtime functions

; User code
define %RuntimeValue @__consair_expr_0() { ... }
define %RuntimeValue @__consair_labeled_factorial_0(...) { ... }

; Entry point
define i32 @main() { ... }
```

## Supported Features

The AOT compiler supports:

### Core Language
- All McCarthy primitives: `cons`, `car`, `cdr`, `atom`, `eq`, `cond`, `lambda`, `label`
- Conditionals: `if`, `cond`
- Quoting: `quote`, `'`

### Arithmetic
- `+`, `-`, `*`, `/`
- Comparisons: `=`, `<`, `>`, `<=`, `>=`

### Type Predicates
- `atom`, `nil?`, `cons?`, `number?`, `not`

### List Operations
- `length`, `append`, `reverse`, `list`, `nth`

### Vectors
- Literal syntax: `<<1 2 3>>`
- `vector-length`, `vector-ref`

### I/O
- `println`, `print`

### Functions
- Named functions with `label`
- Anonymous functions with `lambda`
- Closures (limited support)
- Tail call optimization

## Limitations

Some interpreter features are not yet available in AOT:

- **Macros**: `defmacro` is not supported
- **File I/O**: `slurp`, `spit`
- **Shell**: `shell` command
- **Maps and Sets**: `{...}`, `#{...}`
- **Persistent collections**: `#pvec`, `#pmap`, `#pset`
- **Collection abstractions**: `%seq`, `%first`, etc.
- **Strings**: Limited string support (no string operations)

## Optimization

The generated LLVM IR can be optimized with clang:

```bash
# No optimization (fast compile, slow runtime)
clang factorial.ll -o factorial

# Standard optimization
clang -O2 factorial.ll -o factorial

# Aggressive optimization
clang -O3 factorial.ll -o factorial

# Size optimization
clang -Os factorial.ll -o factorial
```

## Cross-Compilation

With clang, you can cross-compile for different targets:

```bash
# Compile for ARM64 macOS
clang -target arm64-apple-macos factorial.ll -o factorial-arm64

# Compile for x86_64 Linux
clang -target x86_64-linux-gnu factorial.ll -o factorial-x86
```

## Debugging

### View Generated IR

```bash
cadr program.lisp | less
```

### Run with Debug Output

```bash
# LLVM IR interpreter with verbose output
lli -debug program.ll
```

### Verify IR

```bash
llvm-as program.ll -o program.bc
llvm-dis program.bc -o program.verify.ll
```

## Performance Comparison

Typical speedup over interpreter:

| Benchmark | Interpreter | JIT | AOT |
|-----------|-------------|-----|-----|
| factorial(20) | 1x | 10-50x | 50-100x |
| fibonacci(30) | 1x | 20-50x | 100-200x |
| binary-trees | 1x | 5-20x | 20-50x |

Actual performance depends on the workload and optimization level.

## Example Programs

### Fibonacci

```lisp
; fib.lisp
(label fib (lambda (n)
  (cond ((< n 2) n)
        (t (+ (fib (- n 1))
              (fib (- n 2)))))))

(println "fib(30) =" (fib 30))
```

### Tail-Recursive Factorial

```lisp
; factorial-tail.lisp
(label factorial (lambda (n acc)
  (cond ((= n 0) acc)
        (t (factorial (- n 1) (* n acc))))))

(println "20! =" (factorial 20 1))
```

### Binary Trees

```lisp
; See consair-shootout/binary-trees/binary-trees.lisp
```

## Error Handling

```bash
# File not found
$ cadr nonexistent.lisp
Error: File not found: nonexistent.lisp

# Parse error
$ echo "(+ 1" | cadr /dev/stdin
Error: Unclosed opening parenthesis

# Unsupported feature
$ echo "(defmacro foo () nil)" | cadr /dev/stdin
Error: defmacro is not supported in AOT compilation
```

## See Also

- [cons](cons.md) - Interpreter and REPL
- [Language Overview](../language/README.md)
- [Architecture](../internals/architecture.md) - How the compiler works
